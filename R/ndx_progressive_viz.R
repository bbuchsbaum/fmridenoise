#' Generate Progressive Enhancement Visualization
#'
#' Creates a four-panel visualization showing denoising effectiveness
#' at different processing stages of ND-X. Uses htmlwidgets to create
#' static HTML that works without requiring a Shiny server.
#'
#' @param workflow_output List returned by `NDX_Process_Subject` with
#'   Annihilation Mode enabled. It must contain at minimum the elements
#'   `diagnostics_per_pass` (each with a `DES` value),
#'   `beta_history_per_pass` (list of beta matrices per pass),
#'   `pass0_residuals`, and `Y_residuals_final_unwhitened`.
#' @param output_dir Directory to save visualization files
#' @param width Width of the HTML widget
#' @param height Height of the HTML widget
#' @return HTML code to include in the diagnostic report
#' @importFrom htmlwidgets saveWidget
#' @importFrom htmltools tags tagList div HTML
#' @importFrom plotly plot_ly add_trace layout
#' @importFrom magrittr %>%
#' @export
ndx_generate_progressive_enhancement <- function(workflow_output,
                                                output_dir = "./diagnostics",
                                                width = "100%",
                                                height = 800) {
  
  # Check if Annihilation Mode was used
  if (is.null(workflow_output$annihilation_mode_active) || !workflow_output$annihilation_mode_active) {
    return("Progressive enhancement visualization requires Annihilation Mode to be enabled.")
  }
  
  # Create output directory if it doesn't exist
  if (!dir.exists(output_dir)) dir.create(output_dir, recursive = TRUE)
  
  # Define stages
  stages <- c(
    "Stage 1: GLMdenoise-Equivalent",
    "Stage 2: + ND-X Unique Components",
    "Stage 3: + Anisotropic Ridge",
    "Stage 4: Final (Iterative Refinement)"
  )
  
  # Calculate Annihilation Verdict
  verdict_html <- ndx_calculate_annihilation_verdict(workflow_output)
  
  # Create plots for each visualization type
  des_plot <- create_des_progression_plot(workflow_output, stages)
  beta_stability_plot <- create_beta_stability_plot(workflow_output, stages)
  psd_plot <- create_psd_progression_plot(workflow_output, stages)
  
  # Combine all plots into a single HTML widget
  html_widget <- htmltools::div(
    style = "font-family: Arial, sans-serif; padding: 20px;",
    
    # Title section
    htmltools::div(
      style = "text-align: center; margin-bottom: 20px;",
      htmltools::h2("ND-X Progressive Enhancement Visualization"),
      htmltools::p("This visualization shows how each stage of ND-X processing improves denoising effectiveness.")
    ),
    
    # Annihilation Verdict section
    htmltools::HTML(verdict_html),
    
    # Plots section
    htmltools::div(
      style = "display: flex; flex-wrap: wrap; justify-content: space-around;",
      
      htmltools::div(
        style = "width: 48%; margin-bottom: 20px;",
        htmltools::h3("Denoising Efficacy Score (DES)", style = "text-align: center;"),
        des_plot
      ),
      
      htmltools::div(
        style = "width: 48%; margin-bottom: 20px;",
        htmltools::h3("Beta Stability Across Runs", style = "text-align: center;"),
        beta_stability_plot
      ),
      
      htmltools::div(
        style = "width: 48%; margin-bottom: 20px;",
        htmltools::h3("Residual Power Spectral Density", style = "text-align: center;"),
        psd_plot
      ),
      
      htmltools::div(
        style = "width: 48%; margin-bottom: 20px;",
        htmltools::h3("Stage Description", style = "text-align: center;"),
        create_stage_description_panel()
      )
    ),
    
    # Footer
    htmltools::div(
      style = "text-align: center; margin-top: 20px; font-size: 0.9em; color: #666;",
      "Generated by fmridenoise (ND-X)"
    )
  )
  
  # Save as a standalone HTML file
  widget_file <- file.path(output_dir, "progressive_enhancement.html")
  
  # Try to save the widget, but handle test environment issues gracefully
  widget_saved <- tryCatch({
    htmlwidgets::saveWidget(widget = html_widget, 
                           file = widget_file, 
                           selfcontained = TRUE,
                           title = "ND-X Progressive Enhancement")
    TRUE
  }, error = function(e) {
    # In test environments or when htmlwidgets has issues, create a simple HTML file
    warning("Could not save htmlwidget (", e$message, "). Creating simple HTML file instead.")
    simple_html <- paste0(
      "<!DOCTYPE html><html><head><title>ND-X Progressive Enhancement</title></head>",
      "<body><h1>ND-X Progressive Enhancement Visualization</h1>",
      "<p>Visualization would appear here in normal operation.</p>",
      "</body></html>"
    )
    writeLines(simple_html, widget_file)
    FALSE
  })
  
  # Return HTML code to embed this in the main report
  iframe_code <- sprintf('<iframe src="%s" width="%s" height="%s" frameBorder="0"></iframe>', 
                        basename(widget_file), width, height)
  
  return(iframe_code)
}

#' Calculate and Generate Annihilation Verdict HTML
#'
#' @param workflow_output List returned by NDX_Process_Subject
#' @return HTML string with the verdict display
#' @keywords internal
ndx_calculate_annihilation_verdict <- function(workflow_output) {
  if (is.null(workflow_output$gdlite_pcs) || 
      (is.null(workflow_output$rpca_orthogonalized) && 
       is.null(workflow_output$spectral_orthogonalized))) {
    return("")
  }
  
  # Calculate verdict statistics using shared utility
  verdict_stats <- ndx_annihilation_verdict_stats(workflow_output)
  if (is.na(verdict_stats$var_ratio) || is.na(verdict_stats$verdict)) {
    return("")
  }

  verdict_ratio <- verdict_stats$var_ratio
  verdict <- verdict_stats$verdict

  if (verdict == "Tie") {
    color <- "#888888"
    description <- "GLMdenoise and ND-X unique components capture similar noise variance."
  } else if (verdict == "Win") {
    color <- "#5cb85c"
    description <- "ND-X unique components capture additional noise not found by GLMdenoise."
  } else if (verdict == "Decisive Win") {
    color <- "#5bc0de"
    description <- "ND-X unique components capture substantial additional noise."
  } else {
    color <- "#d9534f"
    description <- "ND-X unique components capture more noise variance than GLMdenoise components."
  }
  
  # Create HTML
  html <- sprintf(
    '<div style="text-align: center; margin: 20px; padding: 15px; border: 1px solid #eee; border-radius: 10px; background-color: #f9f9f9;">
      <h3 style="margin-bottom: 15px;">Annihilation Verdict</h3>
      <div style="background-color: %s; color: white; padding: 10px; border-radius: 5px; display: inline-block; font-size: 1.5em; margin-bottom: 10px;">
        <strong>%s</strong>
      </div>
      <p style="margin-bottom: 5px;">Variance Ratio (ND-X Unique / GLMdenoise): <strong>%.2f</strong></p>
      <p style="font-style: italic; font-size: 0.9em;">%s</p>
    </div>',
    color, verdict, verdict_ratio, description
  )
  
  return(html)
}

#' Create DES Progression Plot
#'
#' @param workflow_output Output from `NDX_Process_Subject`. Must contain a
#'   `diagnostics_per_pass` list with a numeric `DES` element for each pass.
#' @param stages Vector of stage names
#' @return Plotly plot object
#' @keywords internal
create_des_progression_plot <- function(workflow_output, stages) {
  if (is.null(workflow_output$diagnostics_per_pass) ||
      length(workflow_output$diagnostics_per_pass) == 0) {
    stop("workflow_output must contain diagnostics_per_pass with DES values")
  }

  des_values <- vapply(workflow_output$diagnostics_per_pass,
                       function(d) d$DES %||% NA_real_,
                       numeric(1))

  stage_labels <- stages[seq_along(des_values)]

  plot_ly(x = stage_labels, y = des_values, type = "scatter",
          mode = "lines+markers",
          marker = list(size = 10, color = "#2C3E50"),
          line = list(width = 3, color = "#2C3E50")) %>%
    layout(xaxis = list(title = "Processing Stage"),
           yaxis = list(title = "Denoising Efficacy Score (DES)"),
           showlegend = FALSE)
}

#' Create Beta Stability Plot
#'
#' @param workflow_output Output from `NDX_Process_Subject`. Must contain a
#'   `beta_history_per_pass` list with beta matrices for each pass.
#' @param stages Vector of stage names
#' @return Plotly plot object
#' @keywords internal
create_beta_stability_plot <- function(workflow_output, stages) {
  if (is.null(workflow_output$beta_history_per_pass) ||
      length(workflow_output$beta_history_per_pass) == 0) {
    stop("workflow_output must contain beta_history_per_pass")
  }

  beta_stability <- calculate_beta_stability(workflow_output$beta_history_per_pass)
  stage_labels <- stages[seq_along(beta_stability)]

  plot_ly(x = stage_labels, y = beta_stability, type = "scatter", mode = "lines+markers",
          marker = list(size = 10, color = "#E74C3C"),
          line = list(width = 3, color = "#E74C3C")) %>%
    layout(xaxis = list(title = "Processing Stage"),
           yaxis = list(title = "Beta Stability (correlation)"),
           showlegend = FALSE)
}

#' Create PSD Progression Plot
#'
#' @param workflow_output Output from `NDX_Process_Subject`. Must contain
#'   `pass0_residuals` and `Y_residuals_final_unwhitened` for PSD estimation.
#' @param stages Vector of stage names
#' @return Plotly plot object
#' @keywords internal
#' @importFrom psd pspectrum
create_psd_progression_plot <- function(workflow_output, stages) {
  if (is.null(workflow_output$pass0_residuals) ||
      is.null(workflow_output$Y_residuals_final_unwhitened)) {
    stop("workflow_output must contain pass0_residuals and Y_residuals_final_unwhitened")
  }

  res0_mean <- rowMeans(workflow_output$pass0_residuals, na.rm = TRUE)
  res_final_mean <- rowMeans(workflow_output$Y_residuals_final_unwhitened, na.rm = TRUE)

  psd0 <- psd::pspectrum(res0_mean, plot = FALSE)
  psdF <- psd::pspectrum(res_final_mean, plot = FALSE)

  plot_ly() %>%
    add_trace(x = psd0$freq, y = psd0$spec, name = "Stage 1", type = "scatter", mode = "lines",
              line = list(width = 2, color = "#3498DB")) %>%
    add_trace(x = psdF$freq, y = psdF$spec, name = "Stage 4", type = "scatter", mode = "lines",
              line = list(width = 3, color = "#16A085")) %>%
    layout(xaxis = list(title = "Frequency"),
           yaxis = list(title = "Power", type = "log"),
           legend = list(x = 0.7, y = 0.9))
}

#' Create Stage Description Panel
#'
#' @return HTML widget with stage descriptions
#' @keywords internal
create_stage_description_panel <- function() {
  html <- '
  <div style="background-color: #f5f5f5; padding: 15px; border-radius: 5px; height: 100%;">
    <ul style="padding-left: 20px;">
      <li style="margin-bottom: 10px;"><strong>Stage 1: GLMdenoise-Equivalent</strong><br>
          Basic GLMdenoise PCs for noise removal.</li>
      <li style="margin-bottom: 10px;"><strong>Stage 2: + ND-X Unique Components</strong><br>
          Addition of RPCA and spectral components orthogonalized against GLMdenoise PCs.</li>
      <li style="margin-bottom: 10px;"><strong>Stage 3: + Anisotropic Ridge</strong><br>
          Different regularization strengths for task vs. noise components.</li>
      <li style="margin-bottom: 10px;"><strong>Stage 4: Final (Iterative Refinement)</strong><br>
          Complete iterative process with adaptive component selection.</li>
    </ul>
  </div>
  '
  
  htmltools::HTML(html)
}

#' Add Progressive Enhancement Visualization to HTML Report
#' Inserts a progressive enhancement visualization section into the diagnostic HTML report.
#'
#' @param html_lines Character vector of HTML lines for the report
#' @param workflow_output List returned by NDX_Process_Subject
#' @param output_dir Directory to save visualization files
#' @return Updated HTML lines with progressive enhancement section
#' @export
ndx_add_progressive_enhancement_to_report <- function(html_lines, workflow_output, output_dir) {
  # Only add if Annihilation Mode was active
  if (!is.null(workflow_output$annihilation_mode_active) && workflow_output$annihilation_mode_active) {
    enhancement_html <- ndx_generate_progressive_enhancement(
      workflow_output = workflow_output,
      output_dir = output_dir
    )
    
    # Find where to insert (before </body> tag)
    body_end_index <- which(html_lines == "</body>")
    
    if (length(body_end_index) > 0) {
      insert_at <- body_end_index[1]
      
      # Create section HTML
      section_html <- c(
        "<h2>Progressive Enhancement Visualization</h2>",
        "<p>This interactive visualization shows how each stage of ND-X processing contributes to the final denoising effectiveness.</p>",
        enhancement_html
      )
      
      # Insert new section
      html_lines <- c(
        html_lines[1:(insert_at-1)],
        section_html,
        html_lines[insert_at:length(html_lines)]
      )
    }
  }
  
  return(html_lines)
} 