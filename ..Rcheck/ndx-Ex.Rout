
R version 4.3.2 (2023-10-31) -- "Eye Holes"
Copyright (C) 2023 The R Foundation for Statistical Computing
Platform: aarch64-apple-darwin20 (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "ndx"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('ndx')
Warning: replacing previous import ‘neuroim2::reorient’ by ‘oro.nifti::reorient’ when loading ‘ndx’
Warning: replacing previous import ‘neuroim2::slice’ by ‘oro.nifti::slice’ when loading ‘ndx’
Warning: replacing previous import ‘neuroim2::origin’ by ‘oro.nifti::origin’ when loading ‘ndx’
Warning: replacing previous import ‘fmrireg::convolve’ by ‘stats::convolve’ when loading ‘ndx’
Warning: replacing previous import ‘rsvd::rpca’ by ‘rpca::rpca’ when loading ‘ndx’
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("ndx_estimate_initial_hrfs")
> ### * ndx_estimate_initial_hrfs
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ndx_estimate_initial_hrfs
> ### Title: Estimate Initial FIR HRFs using Fused Lasso
> ### Aliases: ndx_estimate_initial_hrfs
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # --- Setup from ndx_initial_glm example --- 
> ##D n_time_per_run <- 100; n_runs <- 2; n_voxels <- 200; TR <- 2.0
> ##D total_timepoints <- n_time_per_run * n_runs
> ##D Y_fmri_example <- matrix(rnorm(total_timepoints * n_voxels), 
> ##D                          nrow = total_timepoints, ncol = n_voxels)
> ##D run_idx_example <- rep(1:n_runs, each = n_time_per_run)
> ##D motion_params_example <- matrix(rnorm(total_timepoints * 6), 
> ##D                                 nrow = total_timepoints, ncol = 6)
> ##D events_example <- data.frame(
> ##D   onsets = c(10, 30, 50, 10, 30, 50),
> ##D   durations = c(5, 5, 5, 5, 5, 5),
> ##D   condition = rep(c("TaskA", "TaskB"), each = 3),
> ##D   blockids = c(1, 1, 1, 2, 2, 2)
> ##D )
> ##D # Generate some real signal for TaskA in first 50 voxels
> ##D sf_hrf <- fmrireg::sampling_frame(blocklens = as.numeric(table(run_idx_example)), TR=TR)
> ##D design_taskA <- fmrireg::event_model(~ fmrireg::hrf(TaskA, basis="spmg1"), 
> ##D                                      data=events_example[events_example$condition == "TaskA",], 
> ##D                                      block=events_example$blockids[events_example$condition == "TaskA"],
> ##D                                      sampling_frame=sf_hrf)
> ##D X_taskA_signal <- fmrireg::design_matrix(design_taskA)
> ##D if (ncol(X_taskA_signal) > 0) { 
> ##D    Y_fmri_example[,1:50] <- Y_fmri_example[,1:50] + X_taskA_signal %*% matrix(rnorm(ncol(X_taskA_signal)*50, mean=3, sd=1), ncol=50)
> ##D }
> ##D 
> ##D pass0_out <- ndx_initial_glm(Y_fmri_example, events_example, 
> ##D                                  motion_params_example, run_idx_example, TR)
> ##D 
> ##D # --- Now for ndx_estimate_initial_hrfs --- 
> ##D user_opts_hrf <- list(
> ##D   hrf_fir_taps = 12,            
> ##D   hrf_fir_span_seconds = 24,  
> ##D   good_voxel_R2_threshold = 0.01,
> ##D   cv_folds = 2, 
> ##D   lambda1_grid = 10^seq(-2, 1, length.out = 3),
> ##D   lambda2_grid = 10^seq(-3, 0, length.out = 3),
> ##D   hrf_min_good_voxels = 10,
> ##D   return_full_model = FALSE
> ##D )
> ##D 
> ##D estimated_hrfs_tbl <- ndx_estimate_initial_hrfs(
> ##D   Y_fmri = Y_fmri_example,
> ##D   pass0_residuals = pass0_out$Y_residuals_current,
> ##D   events = events_example,
> ##D   run_idx = run_idx_example,
> ##D   TR = TR,
> ##D   spike_TR_mask = NULL,
> ##D   user_options = user_opts_hrf
> ##D )
> ##D 
> ##D if (!is.null(estimated_hrfs_tbl)) {
> ##D   print(estimated_hrfs_tbl)
> ##D   # Example of unnesting for plotting (requires tidyr and ggplot2)
> ##D   # if (requireNamespace("tidyr", quietly = TRUE) && requireNamespace("ggplot2", quietly = TRUE)) {
> ##D   #   plot_df <- tidyr::unnest(estimated_hrfs_tbl, cols = c(hrf_estimate, taps))
> ##D   #   print(ggplot2::ggplot(plot_df, ggplot2::aes(x = taps * TR, y = hrf_estimate)) +
> ##D   #         ggplot2::geom_line() + ggplot2::geom_point() +
> ##D   #         ggplot2::facet_wrap(~condition) + ggplot2::labs(x="Time (s)", y="Amplitude"))
> ##D   # }
> ##D }
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("ndx_initial_glm")
> ### * ndx_initial_glm
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ndx_initial_glm
> ### Title: Perform an Initial GLM to Generate Residuals and Baseline
> ###   Variance
> ### Aliases: ndx_initial_glm
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # Example Usage (requires fmrireg and appropriate data)
> ##D # Define some hypothetical data
> ##D n_time_per_run <- 100
> ##D n_runs <- 2
> ##D n_voxels <- 10
> ##D TR <- 2.0
> ##D total_timepoints <- n_time_per_run * n_runs
> ##D 
> ##D Y_fmri_example <- matrix(rnorm(total_timepoints * n_voxels), nrow = total_timepoints, ncol = n_voxels)
> ##D run_idx_example <- rep(1:n_runs, each = n_time_per_run)
> ##D motion_params_example <- matrix(rnorm(total_timepoints * 6), nrow = total_timepoints, ncol = 6)
> ##D 
> ##D # Simple events table
> ##D events_example <- data.frame(
> ##D   onsets = c(10, 30, 10, 30),
> ##D   durations = c(5, 5, 5, 5),
> ##D   condition = rep(c("TaskA", "TaskB"), 2),
> ##D   blockids = c(1, 1, 2, 2)
> ##D )
> ##D 
> ##D initial_glm_output <- ndx_initial_glm(Y_fmri_example, events_example,
> ##D                                     motion_params_example, run_idx_example, TR)
> ##D head(initial_glm_output$Y_residuals_current)
> ##D print(initial_glm_output$VAR_BASELINE_FOR_DES)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("ndx_rpca_temporal_components_multirun")
> ### * ndx_rpca_temporal_components_multirun
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ndx_rpca_temporal_components_multirun
> ### Title: Perform Multi-Run Robust PCA and Extract Temporal Nuisance
> ###   Components
> ### Aliases: ndx_rpca_temporal_components_multirun
> 
> ### ** Examples
> 
> ## Not run: 
> ##D # --- Simulate multi-run data ---
> ##D T_run <- 50; V <- 30; N_runs <- 2
> ##D total_T <- T_run * N_runs
> ##D Y_res_cat <- matrix(rnorm(total_T * V), total_T, V)
> ##D run_idx_vec <- rep(1:N_runs, each = T_run)
> ##D 
> ##D # Add some shared low-rank structure (voxel-space pattern, different temporal expression)
> ##D true_V_pattern <- matrix(rnorm(V*2), V, 2) # 2 global voxel patterns
> ##D for (r in 1:N_runs) {
> ##D   run_rows <- which(run_idx_vec == r)
> ##D   # Run-specific temporal modulation of these voxel patterns
> ##D   C_r_signal_run1 <- sin((1:T_run)/5 + r) * 3 + cos((1:T_run)/10 - r/2) * 2
> ##D   C_r_signal_run2 <- cos((1:T_run)/3 - r) * 2.5 + sin((1:T_run/8) + r/3) * 3
> ##D   Y_res_cat[run_rows, ] <- Y_res_cat[run_rows, ] + 
> ##D                            cbind(C_r_signal_run1, C_r_signal_run2) %*% t(true_V_pattern)
> ##D }
> ##D 
> ##D k_target_final <- 3
> ##D user_opts_mrpca <- list(
> ##D   k_per_run_target = 5, # Keep a bit more per run initially
> ##D   rpca_term_delta = 1e-4, # Relax tolerance for example speed
> ##D   rpca_max_iter = 50, # Reduced for example speed
> ##D   rpca_lambda_auto = TRUE
> ##D )
> ##D 
> ##D C_components <- ndx_rpca_temporal_components_multirun(
> ##D   Y_residuals_cat = Y_res_cat, 
> ##D   run_idx = run_idx_vec, 
> ##D   k_global_target = k_target_final, 
> ##D   user_options = user_opts_mrpca
> ##D )
> ##D 
> ##D if (!is.null(C_components)) {
> ##D   print(paste("Dimensions of concatenated C components:", 
> ##D               paste(dim(C_components), collapse="x")))
> ##D   # plot(C_components[,1], type='l', main="First Global RPCA Temporal Component")
> ##D }
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("ndx_spectral_sines")
> ### * ndx_spectral_sines
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: ndx_spectral_sines
> ### Title: Identify Sinusoidal Nuisance Regressors from a Spectrum
> ### Aliases: ndx_spectral_sines
> 
> ### ** Examples
> 
> ## Not run: 
> ##D   set.seed(42)
> ##D   TR_val <- 2.0
> ##D   n_timepoints <- 200
> ##D   time_points <- seq(0, (n_timepoints - 1) * TR_val, by = TR_val)
> ##D 
> ##D   # Create a synthetic residual with a 0.05 Hz sine wave + noise
> ##D   freq_of_interest <- 0.05 # Hz
> ##D   synthetic_signal <- sin(2 * pi * freq_of_interest * time_points)
> ##D   noise <- rnorm(n_timepoints, sd = 0.5)
> ##D   mean_resid <- synthetic_signal + noise
> ##D 
> ##D   U_sines <- ndx_spectral_sines(mean_resid, TR = TR_val, n_sine_candidates = 3)
> ##D   if (!is.null(U_sines)) {
> ##D     print(paste("Generated", ncol(U_sines) / 2, "sine/cosine pairs."))
> ##D     print("Identified frequencies (Hz):")
> ##D     print(attr(U_sines, "freq"))
> ##D     # plot(time_points, U_sines[,1], type='l', main="First Sine Regressor")
> ##D   }
> ## End(Not run)
> 
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  1.127 0.083 1.231 0.001 0.003 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
