% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ndx_workflow.R
\name{NDX_Process_Subject}
\alias{NDX_Process_Subject}
\title{Process a Single Subject through the Full ND-X Iterative Denoising Workflow}
\usage{
NDX_Process_Subject(
  Y_fmri,
  events,
  motion_params,
  run_idx,
  TR,
  spike_TR_mask = NULL,
  user_options = list(),
  verbose = TRUE
)
}
\arguments{
\item{Y_fmri}{A numeric matrix of fMRI data (total_timepoints x voxels), concatenated across runs if applicable.}

\item{events}{A data frame describing experimental events. Must contain columns compatible
with `ndx_initial_glm` and `ndx_estimate_initial_hrfs` (e.g., `onsets`, `durations`, `condition`, `blockids`).}

\item{motion_params}{A numeric matrix of motion parameters (total_timepoints x num_motion_regressors).}

\item{run_idx}{A numeric vector indicating run membership for each row (timepoint)
in `Y_fmri`, `motion_params`, etc.}

\item{TR}{Numeric, repetition time in seconds.}

\item{spike_TR_mask}{Optional. A logical vector of length `nrow(Y_fmri)` where TRUE
indicates a TR to be excluded from HRF estimation and potentially other steps.
If NULL, all TRs are considered valid initially.}

\item{user_options}{A list containing various sub-lists of user-configurable options for each module:
- `opts_pass0`: List of options for `ndx_initial_glm` (e.g., `poly_degree`). This is also used by `ndx_build_design_matrix` for `poly_degree_val`.
- `opts_hrf`: List of options for `ndx_estimate_initial_hrfs` (e.g., `hrf_fir_taps`, `good_voxel_R2_threshold`, `lambda1_grid`, `lambda2_grid`, `cv_folds`).
- `opts_rpca`: List of options for `ndx_rpca_temporal_components_multirun` (e.g., `k_per_run_target`, `rpca_lambda_auto`).
- `opts_spectral`: List of options for `ndx_spectral_sines` (e.g., `n_sine_candidates`, `nyquist_guard_factor`, `k_tapers`, `nw`).
- `opts_whitening`: List of options for `ndx_ar2_whitening` (e.g., `order`, `global_ar_on_design`, `max_ar_failures_prop`).
- `opts_ridge`: List of options including `lambda_ridge` for `ndx_solve_ridge`.
- `task_regressor_names_for_extraction` (character vector): Names of task regressors to extract betas for.
- `max_passes` (integer): Maximum number of iterations for the refinement loop. Default: 3.
- `min_des_gain_convergence` (numeric): Minimum DES gain to continue iteration. Default: 0.005.
- `min_rho_noise_projection_convergence` (numeric): Minimum rho noise projection to continue iteration. Default: 0.01.}

\item{verbose}{Logical, if TRUE, print progress messages. Default: TRUE.}
}
\value{
A list containing key outputs from the workflow, such as:
  - `final_task_betas`: Extracted task betas after the final pass.
  - `diagnostics_per_pass`: A list of diagnostic metrics for each pass.
  - `beta_history_per_pass`: A list of beta estimates from each pass.
  - (Other final pass outputs like residuals, AR coeffs, nuisance components, etc.)
  - `spike_TR_mask`: Logical vector of TRs flagged as spikes from RPCA `S`.
}
\description{
This function orchestrates the core modules of the ND-X pipeline. 
It iteratively performs initial residual generation, FIR HRF estimation, 
nuisance component identification (RPCA and Spectral), AR(2) pre-whitening, 
and ridge regression until convergence or max passes.
}
\examples{
\dontrun{
set.seed(1)
n_time <- 20; n_runs <- 2; n_voxels <- 5
total_T <- n_time * n_runs
Y_ex <- matrix(rnorm(total_T * n_voxels), nrow = total_T, ncol = n_voxels)
run_idx_ex <- rep(1:n_runs, each = n_time)
motion_ex <- matrix(rnorm(total_T * 6), nrow = total_T, ncol = 6)
events_ex <- data.frame(
  onsets = c(5, 15, 5, 15),
  durations = 2,
  condition = rep(c("A", "B"), 2),
  blockids = rep(1:n_runs, each = 2)
)

res <- NDX_Process_Subject(
  Y_fmri = Y_ex,
  events = events_ex,
  motion_params = motion_ex,
  run_idx = run_idx_ex,
  TR = 2
)
}}
