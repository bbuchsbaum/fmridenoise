% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ndx_hrf.R
\name{ndx_estimate_initial_hrfs}
\alias{ndx_estimate_initial_hrfs}
\title{Estimate Initial FIR HRFs using Fused Lasso}
\usage{
ndx_estimate_initial_hrfs(
  Y_fmri,
  pass0_residuals,
  events,
  run_idx,
  TR,
  spike_TR_mask = NULL,
  user_options
)
}
\arguments{
\item{Y_fmri}{Matrix of fMRI data (timepoints x voxels), concatenated across runs.}

\item{pass0_residuals}{Matrix of residuals from `ndx_initial_glm` (timepoints x voxels).}

\item{events}{A data frame describing experimental events. Must contain columns:
`onsets`, `durations`, `condition`, `blockids`.}

\item{run_idx}{Numeric vector indicating run membership for each timepoint in `Y_fmri`.}

\item{TR}{Numeric, repetition time in seconds.}

\item{spike_TR_mask}{Optional. A logical vector of length `nrow(Y_fmri)` where TRUE
indicates a TR to be excluded from HRF estimation (e.g., due to spikes).
If NULL, all TRs are considered valid.}

\item{user_options}{A list of user-configurable options:
- `hrf_fir_taps` (integer): Number of FIR basis functions (e.g., 20).
- `hrf_fir_span_seconds` (numeric): Total duration the FIR model covers (e.g., 24s).
- `good_voxel_R2_threshold` (numeric): R-squared threshold for selecting good voxels
  (e.g., 0.02-0.06). Use `-Inf` to disable voxel filtering.
- `cv_folds` (integer): Number of folds for K-fold cross-validation (e.g., 5).
- `lambda1_grid` (numeric vector): Grid of values for fused penalty `lambda` (L1 on differences).
- `lambda2_grid` (numeric vector): Grid of values for ridge penalty `gamma` (L2 on coefficients).
- `hrf_min_good_voxels` (integer): Minimum number of good voxels required to proceed (e.g., 100).
- `return_full_model` (logical): If TRUE, include the full glmgen model object in the output. Defaults to FALSE.}
}
\value{
A tibble with columns: `condition` (character), `hrf_estimate` (list of numeric vectors),
  `taps` (list of integer vectors). If `user_options$return_full_model` is TRUE, an additional
  list-column `glmgen_fit` is included. Returns NULL if critical errors occur.
}
\description{
Estimates a single "global" or "good-voxel-average" FIR HRF per condition
using `glmgen::fusedlasso`. The HRF is estimated from the robust mean time course
of "good" voxels, identified by R-squared from Pass 0 residuals.
Lambda parameters for fusedlasso are chosen via block-wise k-fold cross-validation.
}
\examples{
\dontrun{
# --- Setup from ndx_initial_glm example --- 
n_time_per_run <- 100; n_runs <- 2; n_voxels <- 200; TR <- 2.0
total_timepoints <- n_time_per_run * n_runs
Y_fmri_example <- matrix(rnorm(total_timepoints * n_voxels), 
                         nrow = total_timepoints, ncol = n_voxels)
run_idx_example <- rep(1:n_runs, each = n_time_per_run)
motion_params_example <- matrix(rnorm(total_timepoints * 6), 
                                nrow = total_timepoints, ncol = 6)
events_example <- data.frame(
  onsets = c(10, 30, 50, 10, 30, 50),
  durations = c(5, 5, 5, 5, 5, 5),
  condition = rep(c("TaskA", "TaskB"), each = 3),
  blockids = c(1, 1, 1, 2, 2, 2)
)
# Generate some real signal for TaskA in first 50 voxels
sf_hrf <- fmrireg::sampling_frame(blocklens = as.numeric(table(run_idx_example)), TR=TR)
design_taskA <- fmrireg::event_model(~ fmrireg::hrf(TaskA, basis="spmg1"), 
                                     data=events_example[events_example$condition == "TaskA",], 
                                     block=events_example$blockids[events_example$condition == "TaskA"],
                                     sampling_frame=sf_hrf)
X_taskA_signal <- fmrireg::design_matrix(design_taskA)
if (ncol(X_taskA_signal) > 0) { 
   Y_fmri_example[,1:50] <- Y_fmri_example[,1:50] + X_taskA_signal \%*\% matrix(rnorm(ncol(X_taskA_signal)*50, mean=3, sd=1), ncol=50)
}

pass0_out <- ndx_initial_glm(Y_fmri_example, events_example, 
                                 motion_params_example, run_idx_example, TR)

# --- Now for ndx_estimate_initial_hrfs --- 
user_opts_hrf <- list(
  hrf_fir_taps = 12,            
  hrf_fir_span_seconds = 24,  
  good_voxel_R2_threshold = 0.01,
  cv_folds = 2, 
  lambda1_grid = 10^seq(-2, 1, length.out = 3),
  lambda2_grid = 10^seq(-3, 0, length.out = 3),
  hrf_min_good_voxels = 10,
  return_full_model = FALSE
)

estimated_hrfs_tbl <- ndx_estimate_initial_hrfs(
  Y_fmri = Y_fmri_example,
  pass0_residuals = pass0_out$Y_residuals_current,
  events = events_example,
  run_idx = run_idx_example,
  TR = TR,
  spike_TR_mask = NULL,
  user_options = user_opts_hrf
)

if (!is.null(estimated_hrfs_tbl)) {
  print(estimated_hrfs_tbl)
  # Example of unnesting for plotting (requires tidyr and ggplot2)
  # if (requireNamespace("tidyr", quietly = TRUE) && requireNamespace("ggplot2", quietly = TRUE)) {
  #   plot_df <- tidyr::unnest(estimated_hrfs_tbl, cols = c(hrf_estimate, taps))
  #   print(ggplot2::ggplot(plot_df, ggplot2::aes(x = taps * TR, y = hrf_estimate)) +
  #         ggplot2::geom_line() + ggplot2::geom_point() +
  #         ggplot2::facet_wrap(~condition) + ggplot2::labs(x="Time (s)", y="Amplitude"))
  # }
}
}
}
