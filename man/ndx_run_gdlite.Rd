% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ndx_gdlite.R
\name{ndx_run_gdlite}
\alias{ndx_run_gdlite}
\title{Run a GLMdenoise-Lite Analysis}
\usage{
ndx_run_gdlite(
  Y_fmri,
  events,
  run_idx,
  TR,
  motion_params = NULL,
  poly_degree = 1,
  k_max = 30L,
  r2_thresh_noise_pool = 0.05,
  tsnr_thresh_noise_pool = 30,
  r2_thresh_good_voxels = 0.05,
  min_K_optimal_selection = 0L,
  detrend_for_tsnr = TRUE,
  perform_final_glm = TRUE
)
}
\arguments{
\item{Y_fmri}{Numeric matrix of fMRI data (timepoints x voxels), concatenated across runs.}

\item{events}{A data frame describing experimental events, required to build task regressors.
Must contain columns `onsets`, `durations`, `condition`, `blockids`.}

\item{run_idx}{Numeric vector indicating run membership for each timepoint.}

\item{TR}{Numeric, repetition time in seconds.}

\item{motion_params}{Optional numeric matrix of motion parameters (timepoints x N).
If provided, these will be included in `X_gd`.}

\item{poly_degree}{Integer or NULL. Degree of polynomial trends to include per run.
If NULL, no polynomial trends are added. From `fmrireg` conventions, 0 means run-specific intercepts.
Default is 1 (linear trend per run).}

\item{k_max}{Integer, maximum number of PCs to extract and consider. Default is 30.}

\item{r2_thresh_noise_pool}{Numeric, R-squared_cv threshold to define noise pool voxels
(voxels with `r2_cv_initial < r2_thresh_noise_pool` are part of noise pool if tSNR is also met).
Default is 0.05.}

\item{tsnr_thresh_noise_pool}{Numeric, tSNR threshold to define noise pool voxels
(voxels with `tsnr > tsnr_thresh_noise_pool` are part of noise pool if R2_cv is also met).
Default is 30.}

\item{r2_thresh_good_voxels}{Numeric, R-squared_cv threshold to define the "good voxel pool"
used for selecting `K_star` (median R2_cv is maximized over voxels with
`r2_cv_initial >= r2_thresh_good_voxels`). Default is 0.05.}

\item{min_K_optimal_selection}{Integer, minimum number of PCs to consider when selecting optimal K.
Default is 0 (allows model with no PCs to be chosen).}

\item{detrend_for_tsnr}{Logical, whether to detrend data before tSNR calculation. Default is TRUE.}

\item{perform_final_glm}{Logical, if TRUE, a final GLM is fit using `X_gd` and the
selected PCs, and its coefficients and residuals are returned. Default is TRUE.}
}
\value{
A list containing various outputs from the GLMdenoise-Lite procedure:
  - `selected_pcs`: The matrix of `K_star` selected principal components.
  - `K_star`: The optimal number of PCs selected.
  - `X_gd`: The base design matrix used (task, motion, polynomials).
  - `r2_cv_initial`: The initial leave-one-run-out R-squared values for `X_gd`.
  - `tsnr_values`: The tSNR value for each voxel.
  - `noise_pool_mask`: Logical vector indicating voxels selected for the noise pool.
  - `good_voxel_mask_for_k_selection`: Logical vector indicating voxels used for K selection.
  - `median_r2cv_by_K`: Median R-squared_cv values for each number of PCs tested.
  - `all_r2cv_per_K`: List of all R-squared_cv vectors for each K.
  - `betas_gdlite`: Coefficients from the final GLM (if `perform_final_glm = TRUE`).
  - `residuals_gdlite`: Residuals from the final GLM (if `perform_final_glm = TRUE`).
  - `all_candidate_pcs`: The full set of `k_max` PCs extracted from the noise pool.
}
\description{
Implements a simplified version of the GLMdenoise procedure to identify
data-driven noise regressors (principal components from residuals).
The steps include:
1. Constructing a base GLM design matrix (`X_gd`) including task regressors,
   polynomial trends, and motion parameters.
2. Calculating leave-one-run-out cross-validated R-squared (`r2_cv_initial`)
   based on `X_gd`.
3. Calculating temporal Signal-to-Noise Ratio (tSNR) for each voxel.
4. Defining a "noise pool" of voxels based on low `r2_cv_initial` and adequate tSNR.
5. Extracting candidate principal components (`pcs_all`) from the residuals of
   `Y_fmri ~ X_gd` within the noise pool.
6. Defining a "good voxel pool" (e.g., `r2_cv_initial` > threshold) for PC selection.
7. Selecting the optimal number of PCs (`K_star`) by maximizing the median `r2_cv`
   (from models `Y_fmri ~ X_gd + K_selected_PCs`) within the good voxel pool.
8. Optionally, performing a final GLM fit using `X_gd` and the `selected_pcs`.
}
