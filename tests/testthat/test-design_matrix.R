context("ndx_build_design_matrix - Design Matrix Construction")

# --- Helper function to create mock estimated_hrfs tibble ---
create_mock_hrfs <- function(conditions = c("TaskA", "TaskB"), taps_per_hrf = 6, TR = 2.0) {
  if (length(conditions) == 0) return(NULL)
  hrf_list <- lapply(conditions, function(cond) {
    list(
      condition = cond,
      hrf_estimate = list(stats::rnorm(taps_per_hrf)), # list-column
      taps = list(1:taps_per_hrf) # list-column, or could be just num_taps
    )
  })
  # Convert list of lists to a tibble more carefully
  # Each element of hrf_list is a row
  df_hrfs <- do.call(rbind, lapply(hrf_list, function(row_list) data.frame(condition=row_list$condition)))
  df_hrfs$hrf_estimate <- lapply(hrf_list, function(row_list) row_list$hrf_estimate[[1]]) # unlist the inner list for hrf_estimate
  df_hrfs$taps <- lapply(hrf_list, function(row_list) row_list$taps[[1]]) # unlist the inner list for taps
  return(tibble::as_tibble(df_hrfs))
}

# --- Basic Test Data Setup ---
TR_test_dm <- 2.0
n_time_per_run_dm <- 30 
n_runs_dm <- 2
total_timepoints_dm <- n_time_per_run_dm * n_runs_dm
run_idx_dm <- rep(1:n_runs_dm, each = n_time_per_run_dm)

events_dm <- data.frame(
  onsets = c(5, 15, 5, 20) * TR_test_dm, # in seconds
  durations = rep(2 * TR_test_dm, 4),
  condition = factor(c("TaskA", "TaskB", "TaskA", "TaskB")),
  blockids = c(1, 1, 2, 2) # ensure blockids align with runs
)

motion_params_dm <- matrix(stats::rnorm(total_timepoints_dm * 3), ncol = 3)
colnames(motion_params_dm) <- paste0("mot", 1:3)

rpca_comps_dm <- matrix(stats::rnorm(total_timepoints_dm * 2), ncol = 2)
# colnames for rpca will be auto-generated by ndx_build_design_matrix

spectral_sines_dm <- matrix(stats::rnorm(total_timepoints_dm * 4), ncol = 4)
colnames(spectral_sines_dm) <- paste0(rep(c("s1", "s2"), each=2), c("_sin", "_cos"))

estimated_hrfs_dm <- create_mock_hrfs(conditions = c("TaskA", "TaskB"), taps_per_hrf = 8, TR = TR_test_dm)

# --- Test Cases ---
test_that("ndx_build_design_matrix runs with all components present (multi-run)", {
  X_full <- NULL
  expect_no_error({
    X_full <- ndx_build_design_matrix(
      estimated_hrfs = estimated_hrfs_dm,
      events = events_dm,
      motion_params = motion_params_dm,
      rpca_components = rpca_comps_dm,
      spectral_sines = spectral_sines_dm,
      run_idx = run_idx_dm,
      TR = TR_test_dm,
      poly_degree = 1, # poly0, poly1, poly2 for degree=1
      verbose = FALSE
    )
  })
  
  expect_true(is.matrix(X_full))
  expect_equal(nrow(X_full), total_timepoints_dm)
  
  # Expected columns: 
  # TaskA (1), TaskB (1) = 2
  # Motion (3) = 3
  # RPCA (2) = 2 
  # Spectral (4) = 4
  # Poly (poly0, poly1, poly2 for degree=1) = 3
  # Run Intercepts (for run2, since poly0 is overall intercept and 2 runs) = 1 
  # Total = 2 + 3 + 2 + 4 + 3 + 1 = 15
  expect_equal(ncol(X_full), 15)
  
  expected_colnames_structure <- c(
    "task_TaskA", "task_TaskB", 
    paste0("mot", 1:3), 
    paste0("rpca_comp_", 1:2), 
    colnames(spectral_sines_dm), 
    "poly0", "poly1", "poly2",
    "run_intercept_2"
  )
  expect_equal(sort(colnames(X_full)), sort(expected_colnames_structure), 
               info = "Column names for X_full do not match expected structure (set comparison).")
})

test_that("ndx_build_design_matrix handles NULL/empty optional components", {
  X_no_nuisance <- NULL
  expect_no_error({
    X_no_nuisance <- ndx_build_design_matrix(
      estimated_hrfs = estimated_hrfs_dm,
      events = events_dm,
      motion_params = NULL,
      rpca_components = NULL,
      spectral_sines = NULL,
      run_idx = run_idx_dm,
      TR = TR_test_dm,
      poly_degree = 0, # only poly0 (overall intercept)
      verbose = FALSE
    )
  })
  expect_true(is.matrix(X_no_nuisance))
  expect_equal(nrow(X_no_nuisance), total_timepoints_dm)
  expect_equal(ncol(X_no_nuisance), 4)
  expected_colnames_no_nuisance <- c("task_TaskA", "task_TaskB", "poly0", "run_intercept_2")
  expect_equal(sort(colnames(X_no_nuisance)), sort(expected_colnames_no_nuisance),
               info = "Colnames for X_no_nuisance do not match (set comparison).")
  
  # Test with 0-column matrices for optional components
  X_zero_col_nuisance <- NULL
  expect_no_error({
    X_zero_col_nuisance <- ndx_build_design_matrix(
      estimated_hrfs = estimated_hrfs_dm,
      events = events_dm,
      motion_params = matrix(numeric(0), nrow=total_timepoints_dm, ncol=0),
      rpca_components = matrix(numeric(0), nrow=total_timepoints_dm, ncol=0),
      spectral_sines = matrix(numeric(0), nrow=total_timepoints_dm, ncol=0),
      run_idx = run_idx_dm,
      TR = TR_test_dm,
      poly_degree = -1, # No polynomials, only run intercepts if multi-run
      verbose = FALSE
    )
  })
  expect_true(is.matrix(X_zero_col_nuisance))
  expect_equal(ncol(X_zero_col_nuisance), 4)
  expected_colnames_zero_col_nuisance <- c("task_TaskA", "task_TaskB", "run_intercept_1", "run_intercept_2")
  expect_equal(sort(colnames(X_zero_col_nuisance)), sort(expected_colnames_zero_col_nuisance),
               info = "Colnames for X_zero_col_nuisance do not match (set comparison).")
})

test_that("ndx_build_design_matrix handles single run correctly", {
  run_idx_single_dm <- rep(1, n_time_per_run_dm)
  events_single_dm <- events_dm[events_dm$blockids == 1,]
  motion_single_dm <- motion_params_dm[1:n_time_per_run_dm, , drop=FALSE]
  rpca_single_dm <- rpca_comps_dm[1:n_time_per_run_dm, , drop=FALSE]
  spectral_single_dm <- spectral_sines_dm[1:n_time_per_run_dm, , drop=FALSE]
  
  X_single_run <- NULL
  expect_no_error({
    X_single_run <- ndx_build_design_matrix(
      estimated_hrfs = estimated_hrfs_dm, 
      events = events_single_dm,
      motion_params = motion_single_dm,
      rpca_components = rpca_single_dm,
      spectral_sines = spectral_single_dm,
      run_idx = run_idx_single_dm,
      TR = TR_test_dm,
      poly_degree = 1, # poly0, poly1, poly2 for degree=1
      verbose = TRUE
    )
  })
  expect_true(is.matrix(X_single_run))
  expect_equal(nrow(X_single_run), n_time_per_run_dm)
  # Task (2) + Motion (3) + RPCA (2) + Spectral (4) + Poly (2: poly0,poly1 for degree=1 on single run) = 13. 
  # No run-specific intercept as only 1 run and poly0 exists.
  expect_equal(ncol(X_single_run), 13)
  # Check for specific poly names if needed, e.g. expect_true(all(c("poly0", "poly1") %in% colnames(X_single_run)))
  
  # Single run, no polynomials -> should add an overall intercept
  X_single_run_no_poly <- NULL
  expect_no_error({
    X_single_run_no_poly <- ndx_build_design_matrix(
      estimated_hrfs = estimated_hrfs_dm,
      events = events_single_dm,
      motion_params = motion_single_dm,
      rpca_components = NULL,
      spectral_sines = NULL,
      run_idx = run_idx_single_dm,
      TR = TR_test_dm,
      poly_degree = -1, # No polys
      verbose = FALSE
    )
  })
  expect_true(is.matrix(X_single_run_no_poly))
  # Task (2) + Motion (3) + Intercept (1) = 6
  expect_equal(ncol(X_single_run_no_poly), 6)
  expect_true("intercept" %in% colnames(X_single_run_no_poly))
})

test_that("ndx_build_design_matrix handles no task HRFs", {
  X_no_task <- NULL
  expect_no_error({
    X_no_task <- ndx_build_design_matrix(
      estimated_hrfs = NULL,
      events = events_dm,
      motion_params = motion_params_dm,
      rpca_components = rpca_comps_dm,
      spectral_sines = spectral_sines_dm,
      run_idx = run_idx_dm,
      TR = TR_test_dm,
      poly_degree = 1, # poly0, poly1, poly2
      verbose = FALSE
    )
  })
  expect_true(is.matrix(X_no_task))
  # Expected: Motion (3) + RPCA (2) + Spectral (4) + Poly (3 for degree=1) + Run Intercept (1) = 13
  expect_equal(ncol(X_no_task), 13)
  expect_false(any(startsWith(colnames(X_no_task), "task_")))
  
  # Empty tibble for HRFs
  empty_hrfs <- tibble::tibble(condition=character(), hrf_estimate=list(), taps=list())
  expect_no_error({
    X_no_task_empty_hrf <- ndx_build_design_matrix(
      estimated_hrfs = empty_hrfs,
      events = events_dm,
      motion_params = motion_params_dm,
      rpca_components = rpca_comps_dm,
      spectral_sines = spectral_sines_dm,
      run_idx = run_idx_dm,
      TR = TR_test_dm,
      poly_degree = 1, # poly0, poly1, poly2
      verbose = FALSE
    )
  })
  expect_equal(ncol(X_no_task_empty_hrf), 13)
})

test_that("ndx_build_design_matrix generates correct polynomial degrees and intercepts", {
  # poly_degree = 0 (intercept only from poly)
  X_poly0 <- ndx_build_design_matrix(estimated_hrfs=NULL, events=events_dm, motion_params=NULL, rpca_components=NULL, spectral_sines=NULL, 
                                   run_idx=run_idx_dm, TR=TR_test_dm, poly_degree=0, verbose=FALSE)
  # poly0 (1) + run_intercept_2 (1) = 2 columns
  expect_equal(ncol(X_poly0), 2)
  expect_true(all(c("poly0", "run_intercept_2") %in% colnames(X_poly0)))
  
  # poly_degree = -1 (no poly, run intercepts only if multi-run)
  X_no_poly_multirun <- ndx_build_design_matrix(estimated_hrfs=NULL, events=events_dm, motion_params=NULL, rpca_components=NULL, spectral_sines=NULL, 
                                             run_idx=run_idx_dm, TR=TR_test_dm, poly_degree= -1, verbose=FALSE)
  # run_intercept_1, run_intercept_2 = 2 columns
  expect_equal(ncol(X_no_poly_multirun), 2)
  expect_true(all(c("run_intercept_1", "run_intercept_2") %in% colnames(X_no_poly_multirun)))
  
  # poly_degree = -1 (no poly, single run -> should add overall intercept)
  run_idx_single_dm_for_poly <- rep(1, n_time_per_run_dm)
  X_no_poly_singlerun <- ndx_build_design_matrix(estimated_hrfs=NULL, events=events_dm[events_dm$blockids==1,], motion_params=NULL, rpca_components=NULL, spectral_sines=NULL, 
                                                run_idx=run_idx_single_dm_for_poly, TR=TR_test_dm, poly_degree= -1, verbose=FALSE)
  # intercept (1) = 1 column
  expect_equal(ncol(X_no_poly_singlerun), 1)
  expect_true("intercept" %in% colnames(X_no_poly_singlerun))
})

test_that("ndx_build_design_matrix errors on row mismatches for inputs", {
  bad_motion <- motion_params_dm[1:(total_timepoints_dm-1), , drop=FALSE]
  expect_error(ndx_build_design_matrix(estimated_hrfs=NULL, events=events_dm, motion_params=bad_motion, rpca_components=NULL, spectral_sines=NULL,
                                      run_idx=run_idx_dm, TR=TR_test_dm, poly_degree=0, verbose=FALSE),
               "Row mismatch: motion_params")
})

test_that("ndx_build_design_matrix errors on invalid TR", {
  expect_error(ndx_build_design_matrix(estimated_hrfs=NULL, events=events_dm, motion_params=NULL, rpca_components=NULL, spectral_sines=NULL,
                                      run_idx=run_idx_dm, TR=c(2, 3), poly_degree=0, verbose=FALSE),
               "single positive number")
  expect_error(ndx_build_design_matrix(estimated_hrfs=NULL, events=events_dm, motion_params=NULL, rpca_components=NULL, spectral_sines=NULL,
                                      run_idx=run_idx_dm, TR=-1, poly_degree=0, verbose=FALSE),
               "single positive number")
})

test_that("ndx_build_design_matrix returns NULL if no regressors are formed", {
  run_idx_single_dm <- rep(1, n_time_per_run_dm)
  X_null <- ndx_build_design_matrix(estimated_hrfs=NULL, events=events_dm, motion_params=NULL, rpca_components=NULL, spectral_sines=NULL, 
                                   run_idx=run_idx_single_dm, TR=TR_test_dm, poly_degree= -1, verbose=FALSE)
  # With poly_degree = -1 and single run, it should produce an intercept column. 
  # To get NULL, we need a scenario where even that fails or is not applicable.
  # If events is such that no task regressors are made, and other components are NULL, and poly_degree is <0 for single run,
  # it will make an intercept. So, this test condition needs rethinking to truly get NULL.
  # The function is designed to *at least* add an intercept for a single run if no polys specified.
  # It returns NULL if X_full_design ends up NULL after filtering empty components OR if total_timepoints_from_run_idx leads to 0-row matrix (from bad run_idx).

  # Test with run_idx implying 0 timepoints (should error earlier, but good to ensure robustness)
  expect_error(ndx_build_design_matrix(estimated_hrfs=NULL, events=events_dm, motion_params=NULL, rpca_components=NULL, spectral_sines=NULL, 
                                     run_idx=integer(0), TR=2, poly_degree=0, verbose=FALSE),
               "run_idx implies one or more runs have zero or negative length" # or similar from sampling_frame
               )

  # If all inputs that could generate columns are NULL or empty, and poly_degree < 0 for single run, result is intercept.
  # To get NULL from `do.call(cbind, all_regressors_filtered)`: all_regressors_filtered must be empty.
  # This means no task, no nuisance, and baseline logic also results in nothing (e.g. poly_degree=-1 and multi-run but run_intercepts fail for some reason - unlikely)
  # The only way for `all_regressors_filtered` to be empty is if no task, no nuisance, and the baseline logic also results in nothing.
  # This is hard to achieve if poly_degree isn't <0 or if it's a single run (where an intercept is forced if no polys).

  # Let's make events that don't match any HRF condition (if HRFs are provided)
  hrf_no_match <- create_mock_hrfs(conditions = c("NonExistent"), taps_per_hrf = 8, TR = TR_test_dm)
  X_no_task_match <- ndx_build_design_matrix(
                         estimated_hrfs = hrf_no_match, 
                         events = events_dm, # events_dm has TaskA, TaskB
                         motion_params = NULL, rpca_components = NULL, spectral_sines = NULL,
                         run_idx = run_idx_single_dm, TR = TR_test_dm, poly_degree = -1, verbose = FALSE)
  # Should still have 'intercept' for single run, poly=-1. So ncol=1.
  expect_equal(ncol(X_no_task_match), 1)
  expect_true("intercept" %in% colnames(X_no_task_match))
  
  # The most direct way to get NULL is if all inputs are truly empty and poly_degree < 0 for multi-run (no forced intercept)
  X_truly_empty <- ndx_build_design_matrix(
                         estimated_hrfs = NULL, 
                         events = events_dm[0,], # Empty events table
                         motion_params = NULL, rpca_components = NULL, spectral_sines = NULL,
                         run_idx = run_idx_dm, # multi-run
                         TR = TR_test_dm, poly_degree = -1, verbose = FALSE)
  # This should result in run_intercept_1 and run_intercept_2 for multi-run, poly_degree=-1
  expect_equal(ncol(X_truly_empty), 2)
  expect_true(all(c("run_intercept_1", "run_intercept_2") %in% colnames(X_truly_empty)))
  # Conclusion: It's difficult to make this function return NULL design matrix if run_idx is valid,
  # as it tries hard to at least include intercepts. It primarily returns NULL if a critical error occurs (like row mismatch after formation).
})

# Test specific logic for FIR basis generation if complex conditions arise
test_that("FIR basis generation in ndx_build_design_matrix handles edge cases", {
  run_idx_single_dm <- rep(1, n_time_per_run_dm)
  # Case 1: HRF estimate has zero length
  hrf_zero_len <- create_mock_hrfs(conditions = c("TaskA"), taps_per_hrf = 0, TR = TR_test_dm)
  # This should be caught by: if (is.null(hrf_coeffs) || length(hrf_coeffs) == 0)
  X_fir_zero <- ndx_build_design_matrix(estimated_hrfs = hrf_zero_len, events = events_dm, motion_params = NULL, rpca_components = NULL, 
                                      spectral_sines = NULL, run_idx = run_idx_single_dm, TR = TR_test_dm, poly_degree = -1, verbose = FALSE)
  expect_false(any(startsWith(colnames(X_fir_zero), "task_")))
  expect_equal(ncol(X_fir_zero), 1) # Should be just the intercept

  # Case 2: No events for a condition listed in HRF table
  hrf_taskC <- create_mock_hrfs(conditions = c("TaskC"), taps_per_hrf = 6, TR = TR_test_dm)
  X_taskC_no_events <- ndx_build_design_matrix(estimated_hrfs = hrf_taskC, events = events_dm, motion_params = NULL, rpca_components = NULL,
                                             spectral_sines = NULL, run_idx = run_idx_single_dm, TR = TR_test_dm, poly_degree = -1, verbose = FALSE)
  expect_false(any(startsWith(colnames(X_taskC_no_events), "task_")))
  expect_equal(ncol(X_taskC_no_events), 1) # Intercept
})

test_that("drop_zero_variance option removes constant regressors", {
  const_rpca <- matrix(1, nrow = total_timepoints_dm, ncol = 1)
  X_drop <- ndx_build_design_matrix(
    estimated_hrfs = estimated_hrfs_dm,
    events = events_dm,
    motion_params = motion_params_dm,
    rpca_components = const_rpca,
    spectral_sines = NULL,
    run_idx = run_idx_dm,
    TR = TR_test_dm,
    poly_degree = 0,
    verbose = FALSE,
    drop_zero_variance = TRUE
  )
  expect_false("rpca_comp_1" %in% colnames(X_drop))
})


test_that("non-sequential run_idx are mapped correctly", {
  run_idx_ns <- rep(c(10, 20), each = n_time_per_run_dm)
  events_ns <- events_dm
  events_ns$blockids <- c(10, 10, 20, 20)

  info <- ndx:::.ndx_validate_design_inputs(run_idx_ns, motion_params_dm,
                                            rpca_comps_dm, spectral_sines_dm)
  expect_equal(unique(info$run_idx_mapped), c(1, 2))
  expect_equal(info$run_lengths, c(n_time_per_run_dm, n_time_per_run_dm))

  X_ns <- ndx_build_design_matrix(
    estimated_hrfs = estimated_hrfs_dm,
    events = events_ns,
    motion_params = motion_params_dm,
    rpca_components = rpca_comps_dm,
    spectral_sines = spectral_sines_dm,
    run_idx = run_idx_ns,
    TR = TR_test_dm,
    poly_degree = 1,
    verbose = FALSE
  )
  expect_true(is.matrix(X_ns))
  expect_equal(nrow(X_ns), total_timepoints_dm)
})

test_that("run_idx with NA triggers error", {
  bad_run_idx <- run_idx_dm
  bad_run_idx[5] <- NA
  expect_error(
    ndx_build_design_matrix(
      estimated_hrfs = estimated_hrfs_dm,
      events = events_dm,
      motion_params = motion_params_dm,
      rpca_components = rpca_comps_dm,
      spectral_sines = spectral_sines_dm,
      run_idx = bad_run_idx,
      TR = TR_test_dm,
      poly_degree = 1,
      verbose = FALSE
    ),
    "run_idx contains NA"
  )
})



test_that("ndx_build_design_matrix errors when events blockids are invalid", {
  events_bad <- events_dm
  events_bad$blockids[1] <- 99
  expect_error(
    ndx_build_design_matrix(
      estimated_hrfs = estimated_hrfs_dm,
      events = events_bad,
      motion_params = motion_params_dm,
      rpca_components = rpca_comps_dm,
      spectral_sines = spectral_sines_dm,
      run_idx = run_idx_dm,
      TR = TR_test_dm,
      poly_degree = 1,
      verbose = FALSE
    ),
    "events\\$blockids"
  )
})

test_that("non-sequential run_idx are mapped for events", {
  run_idx_nonseq <- rep(c(10, 20), each = n_time_per_run_dm)
  events_nonseq <- events_dm
  events_nonseq$blockids <- c(10, 10, 20, 20)

  X_nonseq <- ndx_build_design_matrix(
    estimated_hrfs = estimated_hrfs_dm,
    events = events_nonseq,
    motion_params = motion_params_dm,
    rpca_components = rpca_comps_dm,
    spectral_sines = spectral_sines_dm,
    run_idx = run_idx_nonseq,
    TR = TR_test_dm,
    poly_degree = 0,
    verbose = FALSE
  )
  expect_true(is.matrix(X_nonseq))
  expect_equal(nrow(X_nonseq), total_timepoints_dm)
  expect_true(any(grepl("run_intercept_20", colnames(X_nonseq))))
})
                         
test_that("near-constant regressors are removed when variance below epsilon", {
  set.seed(123)
  near_const_rpca <- matrix(1 + rnorm(total_timepoints_dm, sd = 1e-10), ncol = 1)
  X_drop_near <- ndx_build_design_matrix(
    estimated_hrfs = estimated_hrfs_dm,
    events = events_dm,
    motion_params = motion_params_dm,
    rpca_components = near_const_rpca,
    spectral_sines = NULL,
    run_idx = run_idx_dm,
    TR = TR_test_dm,
    poly_degree = 0,
    verbose = FALSE,
    drop_zero_variance = TRUE,
    zero_var_epsilon = 1e-8
  )
  expect_false("rpca_comp_1" %in% colnames(X_drop_near))
})
